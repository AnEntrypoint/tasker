---
description: 
globs: 
alwaysApply: true
---
# Task Execution
- Tasker is a modular content generation system using QuickJS for secure, sandboxed task execution.
- The QuickJS executor in supabase/functions/quickjs/index.ts creates an isolated JavaScript environment, injects global objects like console and fetch, and executes task code with access to service proxies through the tools object.
- The QuickJS executor in supabase/functions/quickjs/index.ts was modified to properly handle promises by implementing a job processing loop that explicitly calls rt.executePendingJobs() to process pending jobs in the QuickJS runtime while waiting for async operations to complete.
- The QuickJS executor uses newAsyncContext() for Asyncify support, ctx.resolvePromise() for promise settlement, and async wrapper functions in VM proxies to properly handle promises in the QuickJS environment to properly handle promises.
- The QuickJS executor should be configured to properly handle promises by waiting for and resolving outstanding promises.
- The VM proxy generator in QuickJS returns the promise handle directly from __callHostTool__ without awaiting it, allowing the VM's await to operate on this handle via Asyncify.
- The VM proxy generator in QuickJS was optimized for OpenAI API calls by implementing aggressive parameter optimization (limiting max_tokens to 150, using gpt-3.5-turbo model, setting temperature to 0.3, adding brevity instructions) and using a more aggressive polling strategy with minimal intervals (no delay for first 50 attempts, then 2ms intervals).
- The system uses Supabase Edge Functions for task execution, with QuickJS providing a sandboxed JavaScript environment.
- Tasks are defined as JavaScript modules with a standard export pattern and JSDoc comments for documentation.
- Task functions should be defined as async functions to properly use await for asynchronous operations like API calls in the QuickJS environment.
- The database service uses the sdk-http-wrapper library to create a service proxy for Supabase, allowing tasks to query the database through the wrappedsupabase edge function.
- The wrappedsupabase service creates a Supabase client using the service role key and forwards API requests to it, supporting both generic SDK proxy requests and service-specific proxy requests.
- The wrappedopenai service retrieves the OpenAI API key from the keystore service, initializes the OpenAI client, and forwards method calls to the OpenAI API, handling authentication and error handling.
- The wrappedwebsearch service implements a web search using DuckDuckGo's HTML API, extracting titles, URLs, and snippets from search results and returning them in a structured format.
- The wrappedkeystore service manages API keys securely, providing methods to get, set, and list keys, with keys organized by namespace for different services, using the service role key for database access.
- The wrapped services use the executeMethodChain function from sdk-http-wrapper to process API requests, which extracts method chains from the request body and executes them on the service object.
- The sdk-http-wrapper library provides a client-server architecture for proxying SDK calls over HTTP, with a client that creates JavaScript proxies to record method chains and a server that executes those chains on the actual SDK instances.
- The client.js module creates dynamic proxies that intercept property access and method calls, recording them in a chain, and then sending the chain to the server for execution when a promise method is accessed.
- The buildProxy function in client.js creates a recursive proxy that captures property accesses as 'get' operations and method calls as 'call' operations, building a chain that represents the sequence of operations to be executed.
- The server.js module provides the executeMethodChain function that recursively resolves a chain of property accesses and method calls on an SDK instance, awaiting promises at each step to ensure proper asynchronous execution.
- The executeTask function fetches the task from the database, configures service proxies, prepares the runtime environment, and calls the QuickJS edge function with the task code, input, and configuration.
- The executeTask function includes a timeout mechanism for the QuickJS function call, with a default timeout of 90 seconds, and handles errors by formatting them with appropriate error messages and status codes.
- QuickJS documentation at https://bellard.org/quickjs/quickjs.html should be used as a guide for implementation.
- QuickJS documentation is available at https://bellard.org/quickjs/quickjs.pdf
- QuickJS requires explicit job processing via JS_ExecutePendingJob() to handle promises and async operations, with no implicit event loop in embedded environments.
- The SDK wrapper should be implemented like sdk-http-wrapper src/client.js or import it directly.
- QuickJS has an issue with Asyncify implementation in the Supabase/Deno environment where awaiting asyncified host functions (newAsyncifiedFunction) from within the VM causes the system to hang.

# Task Management
- The publish.ts script discovers task files in taskcode/endpoints/ directory, extracts JSDoc comments for descriptions, and upserts tasks into the task_functions table in Supabase.
- The publish.ts script supports command-line arguments: --all to publish all tasks, --specific [taskname] to publish specific tasks, and --list to display tasks in the database.
- The JSDoc parser extracts task documentation from code comments, parsing @param, @returns, and @throws tags to generate structured metadata for task parameters, return values, and error conditions.
- The schema generator converts parsed JSDoc information into structured schemas in different formats (OpenAPI, OpenAI function calling, JSON) for API documentation and client integration.
- The tasks edge function handles various routes: task execution (/tasks), schema generation (/schema), task listing (/list), task creation/update (/create), task deletion (/delete), and OpenAPI schema generation (/openapi).
- The tasks edge function first checks if a task exists in the TaskRegistry, and if so, executes it directly; otherwise, it fetches the task from the database and executes it using the executeTask function.
- The TaskRegistry class manages task registration, discovery, and execution, providing methods to register tasks, check if tasks exist, get task code and metadata, and execute tasks with input parameters and logs.

# Task Specifics
- The blog-generator task formats search results as context for OpenAI using a specific format: "Source X: [Title]\nURL: [URL]\nSummary: [Snippet]\n\n" for each result.
- The blog generator task has a maximum runtime of approximately 40 seconds.
- The module-diagnostic task checks the global scope, tools and tasks availability, require function, and module registry to diagnose module loading issues in the QuickJS environment.
- The blog-generator-cli.js is a simple command-line interface that calls the tasks edge function with the blog-generator task name and a topic from command-line arguments.
- The test-blog-generator.js provides a more detailed CLI with support for additional options (model, searchResults, temperature, maxTokens) and displays the generated blog content, sources, metadata, and execution logs.
- The test-module-diagnostic.js runs the module-diagnostic task to check the QuickJS environment, displaying information about global scope, tools and tasks availability, and module loading status.
- The response-formatter.ts module provides utilities for formatting task responses, including safeStringify for handling complex objects, formatTaskResult for standardizing response structure, and formatLogMessage for consistent log formatting.
- The module-generator.ts file returns empty module definitions for 'tools' and 'tasks', as the actual code is loaded directly by QuickJS rather than being generated.
- The test-live-openai.ts file demonstrates how to use the OpenAI service proxy, testing both chat completions and embeddings with the wrapped service.
- The test-live-websearch.ts file tests the web search service with search queries and concurrent requests, demonstrating how to use the websearch service proxy.
- The test-live-keystore.ts file tests the keystore service with namespace operations, key operations (set, get, list), and concurrent operations, using the service role key for authentication.
- The test-live-supabase.ts file tests the Supabase service with database operations (select, insert) and authentication operations (sign up, sign in), using the anon key for authentication.

# Database Interaction
- The database.ts module creates a service proxy for Supabase using the sdk-http-wrapper library.
- The fetchTaskFromDatabase function retrieves task code from the task_functions table, supporting lookup by either task ID or task name.
# Types
- The types/index.ts file defines interfaces for task information, execution results, schema properties, parsed JSDoc information, generated schemas, OpenAPI schemas, and OpenAI schemas.
